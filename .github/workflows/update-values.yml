name: Chart Version Update Automation (Filtered Logic)

on:
  push:
    branches:
      - main
    paths:
      # Use a broad path filter to ensure any relevant file change triggers the workflow
      - '*/values.yaml'

jobs:
  run-chart-update:
    runs-on: self-hosted # Use 'local' if you prefer, but 'self-hosted' is generally sufficient
    
    permissions:
      contents: write
      packages: read 
    
    env:
      CHARTMUSEUM_URL: http://192.168.64.2:30080
      REPO_ROOT: ${{ github.workspace }}

    steps:
      - name: ‚¨áÔ∏è Checkout Source Repository
        # We fetch the entire history so git diff can compare against the previous commit
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # IMPORTANT: Gets full history for accurate 'git diff'

      - name: ‚¨áÔ∏è Clone ArgoCD Apps Repository
        shell: bash
        run: |
          export ARGOCD_LOCAL="$RUNNER_TEMP/argo-apps-clone" 
          echo "Cloning ArgoCD Apps repo to $ARGOCD_LOCAL"
          if ! git clone --depth 1 https://github.com/sidhuni/argo-apps.git "$ARGOCD_LOCAL"; then
              echo "‚ùå ERROR: Failed to clone ArgoCD repository."
              exit 1
          fi
          
      - name: üèÉ Run Filtered Automation Logic
        shell: bash
        run: |
          set -euo pipefail
          
          # Define necessary runtime variables inside the shell
          export ARGOCD_LOCAL="$RUNNER_TEMP/argo-apps-clone"
          export REPO_ROOT="${{ env.REPO_ROOT }}"
          
          echo "--- 1. Discovering Changed Apps ---"
          
          # Get list of files changed between the commit BEFORE this run and the current commit
          # Filters for 'appX/values.yaml' pattern and extracts only the directory name (app1, app2, etc.)
          CHANGED_APPS_RAW=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep -E '^app[0-9]+/values\.yaml$' || true)
          
          # Extract only the directory names (e.g., 'app1' from 'app1/values.yaml')
          # Sorts the final list for consistent processing order.
          APPS_TO_PROCESS=($(echo "$CHANGED_APPS_RAW" | sed -E 's/(\/values\.yaml)//' | sort -V))

          if [ ${#APPS_TO_PROCESS[@]} -eq 0 ]; then
              echo "‚úÖ No relevant 'values.yaml' files were changed in this commit. Automation complete."
              exit 0 # Exit gracefully if no files matched the filter
          fi
          
          echo "Apps to process based on commit changes: ${APPS_TO_PROCESS[*]}"

          TEMPLATE_CHART="./template/Chart.yaml"
          TEMPLATE_VERSION=$(grep "^version:" "$TEMPLATE_CHART" | awk '{print $2}')
          
          BASE_MAJOR=$(echo "$TEMPLATE_VERSION" | cut -d. -f1)
          BASE_MINOR=$(echo "$TEMPLATE_VERSION" | cut -d. -f2)
          BASE_PATCH=$(echo "$TEMPLATE_VERSION" | cut -d. -f3)

          # --- 2. Loop Through ONLY THE CHANGED APPS ---
          for i in "${!APPS_TO_PROCESS[@]}"; do
              APP_NAME="${APPS_TO_PROCESS[$i]}" 
              APP_DIR="./$APP_NAME"
              
              # Calculate new version (Index 'i' is now relative to the small, filtered list)
              # NOTE: Version is based on the index *of the filtered list* (0, 1, 2, etc.)
              PATCH=$((BASE_PATCH + i + 1))
              NEW_VERSION="$BASE_MAJOR.$BASE_MINOR.$PATCH"

              BASE_CHART_NAME=$(grep "^name:" "$TEMPLATE_CHART" | awk '{print $2}')
              APP_NUMBER=$(echo "$APP_NAME" | grep -o '[0-9]\+' || echo "")
              NEW_CHART_NAME="${BASE_CHART_NAME}${APP_NUMBER}"

              echo "---------------------------------------"
              echo "Processing $APP_NAME, Version: $NEW_VERSION, Chart: $NEW_CHART_NAME"

              mkdir -p "$APP_DIR/charts"
              cp "$TEMPLATE_CHART" "$APP_DIR/Chart.yaml"
              
              sed -i '' "s/^name:.*/name: $NEW_CHART_NAME/" "$APP_DIR/Chart.yaml"
              sed -i '' "s/^version:.*/version: $NEW_VERSION/" "$APP_DIR/Chart.yaml"

              # Build, Package, and Upload
              if ! cd "$APP_DIR"; then exit 1; fi
              helm dependency update >/dev/null
              PACKAGE_OUTPUT=$(helm package . --destination .)
              PACKAGE_FILE=$(echo "$PACKAGE_OUTPUT" | awk -F': ' '/Successfully packaged chart/ {print $NF}')
              
              echo "Uploading $PACKAGE_FILE..."
              curl --fail --silent --show-error --data-binary "@$PACKAGE_FILE" "${{ env.CHARTMUSEUM_URL }}/api/charts"
              echo " Upload complete."

              if ! cd "$REPO_ROOT"; then exit 1; fi

              # Update ArgoCD App YAML in the CLONED repo
              APP_FILE="$ARGOCD_LOCAL/application/$APP_NAME.yaml"
              if [ ! -f "$APP_FILE" ]; then echo "‚ùå Error: ArgoCD app file not found: $APP_FILE"; exit 1; fi
              
              sed -i '' "s/targetRevision:.*/targetRevision: $NEW_VERSION/" "$APP_FILE"
              sed -i '' "s/chart:.*/chart: $NEW_CHART_NAME/" "$APP_FILE"

              # Cleanup local chart files
              rm -rf "$APP_DIR/Chart.yaml" "$APP_DIR/Chart.lock" "$APP_DIR/*.tgz" "$APP_DIR/charts"
              
              echo "‚úÖ $APP_NAME processed successfully."
          done

      - name: ‚¨ÜÔ∏è Commit and Push ArgoCD Changes
        shell: bash
        run: |
          export ARGOCD_LOCAL="$RUNNER_TEMP/argo-apps-clone" 
          if ! cd "$ARGOCD_LOCAL"; then exit 1; fi
          
          git config user.name github-actions
          git config user.email github-actions@github.com
          
          if git diff --exit-code application/*.yaml >/dev/null; then
              echo "No changes detected in ArgoCD application YAMLs. Skipping commit."
          else
              echo "Committing changes to ArgoCD repository..."
              git add application/*.yaml
              git commit -m "Automated update: Chart versions synced with values change"
              git push
              echo "Pushed updated ArgoCD manifests."
          fi

      - name: ‚¨ÜÔ∏è Commit and Push Changes in Values Repository (Source Repo)
        shell: bash
        run: |
          if ! cd ${{ env.REPO_ROOT }}; then exit 1; endif
          
          git config user.name github-actions
          git config user.email github-actions@github.com
          
          if git diff --exit-code */values.yaml >/dev/null; then
              echo "No uncommitted changes in values.yaml files in source repo."
          else
              echo "Committing changes to the source repository (values.yaml)..."
              git add */values.yaml
              git commit -m "Automated update: Synchronized values.yaml changes."
              git push
              echo "Pushed changes to the source repository."
          fi

      - name: üöÄ Apply Parent Application (Force Sync on Cluster)
        shell: bash
        run: |
          export PARENT_APP_FILE="$RUNNER_TEMP/argo-apps-clone/parentapp.yaml"
          echo "Applying parent application manifest: $PARENT_APP_FILE..."
          
          if [ -f "$PARENT_APP_FILE" ]; then
              kubectl apply -f "$PARENT_APP_FILE"
              echo "Parent application applied successfully."
          else
              echo "‚ùå ERROR: Parent app file not found at $PARENT_APP_FILE. Skipping kubectl apply."
              exit 1 
          fi